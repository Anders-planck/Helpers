{
  "version": 3,
  "sources": ["../vue-prism-editor/src/Editor.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { defineComponent, h } from 'vue';\n\nimport './styles.css';\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = typeof window !== 'undefined' && navigator && /Win/i.test(navigator.platform);\nconst isMacLike = typeof window !== 'undefined' && navigator && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nexport interface EditorProps {\n  lineNumbers: boolean;\n  autoStyleLineNumbers: boolean;\n  readonly: boolean;\n  value: string;\n  highlight: () => string;\n  tabSize: number;\n  insertSpaces: boolean;\n  ignoreTabKey: boolean;\n  placeholder: string;\n}\nexport interface Record {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n}\n\nexport interface History {\n  stack: Array<Record & { timestamp: number }>;\n  offset: number;\n}\n\nexport const PrismEditor = defineComponent({\n  props: {\n    lineNumbers: {\n      type: Boolean,\n      default: false,\n    },\n    autoStyleLineNumbers: {\n      type: Boolean,\n      default: true,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    modelValue: {\n      type: String,\n      default: '',\n    },\n    highlight: {\n      type: Function,\n      required: true,\n    },\n    tabSize: {\n      type: Number,\n      default: 2,\n    },\n    insertSpaces: {\n      type: Boolean,\n      default: true,\n    },\n    ignoreTabKey: {\n      type: Boolean,\n      default: false,\n    },\n    placeholder: {\n      type: String,\n      default: '',\n    },\n  },\n  data() {\n    return {\n      capture: true,\n      history: {\n        stack: [],\n        offset: -1,\n      } as History,\n      lineNumbersHeight: '20px',\n      codeData: '',\n    };\n  },\n  watch: {\n    modelValue: {\n      immediate: true,\n      handler(newVal: string): void {\n        if (!newVal) {\n          this.codeData = '';\n        } else {\n          this.codeData = newVal;\n        }\n      },\n    },\n    content: {\n      immediate: true,\n      handler(): void {\n        if (this.lineNumbers) {\n          this.$nextTick(() => {\n            this.setLineNumbersHeight();\n          });\n        }\n      },\n    },\n    lineNumbers(): void {\n      this.$nextTick(() => {\n        this.styleLineNumbers();\n        this.setLineNumbersHeight();\n      });\n    },\n  },\n  computed: {\n    isEmpty(): boolean {\n      return this.codeData.length === 0;\n    },\n    content(): string {\n      const result = this.highlight(this.codeData) + '<br />';\n      // todo: VNode support?\n      return result;\n    },\n    lineNumbersCount(): number {\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\n      return totalLines;\n    },\n  },\n  mounted() {\n    this._recordCurrentState();\n    this.styleLineNumbers();\n  },\n\n  methods: {\n    setLineNumbersHeight(): void {\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\n    },\n    styleLineNumbers(): void {\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\n\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\n      const editorStyles = window.getComputedStyle($editor);\n\n      this.$nextTick(() => {\n        const btlr: any = 'border-top-left-radius';\n        const bblr: any = 'border-bottom-left-radius';\n        if (!$lineNumbers) return;\n        $lineNumbers.style[btlr] = editorStyles[btlr];\n        $lineNumbers.style[bblr] = editorStyles[bblr];\n        $editor.style[btlr] = '0';\n        $editor.style[bblr] = '0';\n\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\n        stylesList.forEach((style: any) => {\n          $lineNumbers.style[style] = editorStyles[style];\n        });\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\n      });\n    },\n    _recordCurrentState(): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n      // Save current state of the input\n      const { value, selectionStart, selectionEnd } = input;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd,\n      });\n    },\n    _getLines(text: string, position: number): Array<string> {\n      return text.substring(0, position).split('\\n');\n    },\n    _applyEdits(record: Record): void {\n      // Save last selection state\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n      const last = this.history.stack[this.history.offset];\n\n      if (last && input) {\n        this.history.stack[this.history.offset] = {\n          ...last,\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd,\n        };\n      }\n\n      // Save the changes\n      this._recordChange(record);\n      this._updateInput(record);\n    },\n    _recordChange(record: Record, overwrite = false): void {\n      const { stack, offset } = this.history;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this.history.stack = stack.slice(0, offset + 1);\n\n        // Limit the number of operations to 100\n        const count = this.history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          const extras = count - HISTORY_LIMIT;\n\n          this.history.stack = stack.slice(extras, count);\n          this.history.offset = Math.max(this.history.offset - extras, 0);\n        }\n      }\n\n      const timestamp = Date.now();\n\n      if (overwrite) {\n        const last = this.history.stack[this.history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n\n          // Match the last word in the line\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n          // Get the previous line\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\n\n          // Get the current line\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this.history.stack[this.history.offset] = {\n              ...record,\n              timestamp,\n            };\n\n            return;\n          }\n        }\n      }\n\n      // Add the new operation to the stack\n      this.history.stack.push({ ...record, timestamp });\n      this.history.offset++;\n    },\n\n    _updateInput(record: Record): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n\n      // Update values and selection state\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      this.$emit('update:modelValue', record.value);\n      // this.props.onValueChange(record.value);\n    },\n    handleChange(e: KeyboardEvent): void {\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      this._recordChange(\n        {\n          value,\n          selectionStart,\n          selectionEnd,\n        },\n        true\n      );\n      this.$emit('update:modelValue', value);\n      // this.props.onValueChange(value);\n    },\n    _undoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the previous edit\n      const record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.max(offset - 1, 0);\n      }\n    },\n    _redoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the next edit\n      const record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    },\n    handleKeyDown(e: KeyboardEvent): void {\n      // console.log(navigator.platform);\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\n\n      // onKeyDown(e);\n      this.$emit('keydown', e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        (<HTMLTextAreaElement>e.target).blur();\n        this.$emit('blur', e);\n      }\n\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const nextValue = value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n                return line.substring(tabCharacter.length);\n              }\n\n              return line;\n            })\n            .join('\\n');\n\n          if (value !== nextValue) {\n            const startLineText = linesBeforeCaret[startLine];\n\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter)\n                ? selectionStart - tabCharacter.length\n                : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: value\n              .split('\\n')\n              .map((line, i) => {\n                if (i >= startLine && i <= endLine) {\n                  return tabCharacter + line;\n                }\n\n                return line;\n              })\n              .join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n          });\n        } else {\n          const updatedSelection = selectionStart + tabCharacter.length;\n\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        const hasSelection = selectionStart !== selectionEnd;\n        const textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          const updatedSelection = selectionStart - tabCharacter.length;\n\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          const line = this._getLines(value, selectionStart).pop();\n          const matches = line?.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault();\n\n            // Preserve indentation on inserting a new line\n            const indent = '\\n' + matches[0];\n            const updatedSelection = selectionStart + indent.length;\n\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: updatedSelection,\n              selectionEnd: updatedSelection,\n            });\n          }\n        }\n      } else if (\n        e.keyCode === KEYCODE_PARENS ||\n        e.keyCode === KEYCODE_BRACKETS ||\n        e.keyCode === KEYCODE_QUOTE ||\n        e.keyCode === KEYCODE_BACK_QUOTE\n      ) {\n        let chars;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        }\n\n        // console.log(isMacLike, \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));\n\n        // If text is selected, wrap them in the characters\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          this._applyEdits({\n            value:\n              value.substring(0, selectionStart) +\n              chars[0] +\n              value.substring(selectionStart, selectionEnd) +\n              chars[1] +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart,\n            selectionEnd: selectionEnd + 2,\n          });\n        }\n      } else if (\n        (isMacLike\n          ? // Trigger undo with \u2318+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z\n          : // Trigger undo with Ctrl+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n        !e.shiftKey &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._undoEdit();\n      } else if (\n        (isMacLike\n          ? // Trigger redo with \u2318+Shift+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n          : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault();\n\n        // Toggle capturing tab key so users can focus away\n        this.capture = !this.capture;\n      }\n    },\n  },\n  render() {\n    const lineNumberWidthCalculator = h(\n      'div',\n      {\n        class: 'prism-editor__line-width-calc',\n        style: 'height: 0px; visibility: hidden; pointer-events: none;',\n      },\n      '999'\n    );\n    const lineNumbers = h(\n      'div',\n      {\n        class: 'prism-editor__line-numbers',\n        style: {\n          'min-height': this.lineNumbersHeight,\n        },\n        'aria-hidden': 'true',\n      },\n      [\n        lineNumberWidthCalculator,\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\n          return h('div', { class: 'prism-editor__line-number token comment' }, `${++index}`);\n        }),\n      ]\n    );\n\n    const textarea = h('textarea', {\n      ref: 'textarea',\n      onInput: this.handleChange,\n      onKeydown: this.handleKeyDown,\n      onClick: ($event: MouseEvent) => {\n        this.$emit('click', $event);\n      },\n      onKeyup: ($event: KeyboardEvent) => {\n        this.$emit('keyup', $event);\n      },\n      onFocus: ($event: FocusEvent) => {\n        this.$emit('focus', $event);\n      },\n      onBlur: ($event: FocusEvent) => {\n        this.$emit('blur', $event);\n      },\n      class: {\n        'prism-editor__textarea': true,\n        'prism-editor__textarea--empty': this.isEmpty,\n      },\n      spellCheck: 'false',\n      autocapitalize: 'off',\n      autocomplete: 'off',\n      autocorrect: 'off',\n      'data-gramm': 'false',\n      placeholder: this.placeholder,\n      'data-testid': 'textarea',\n      readonly: this.readonly,\n      value: this.codeData,\n    });\n    const preview = h('pre', {\n      ref: 'pre',\n      class: 'prism-editor__editor',\n      'data-testid': 'preview',\n      innerHTML: this.content,\n    });\n    const editorContainer = h('div', { class: 'prism-editor__container' }, [textarea, preview]);\n    return h('div', { class: 'prism-editor-wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\n  },\n});\n"],
  "mappings": "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",
  "names": []
}
